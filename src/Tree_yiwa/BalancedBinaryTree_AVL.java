package Tree_yiwa;

/**
 * 二叉查找树查找过程时间复杂度为O(logN)在某种极端情况下(树的结构为单向左子树或者右子树)会上升为O(N)，因此提出了平衡二叉树（AVL）
 * https://blog.csdn.net/javazejian/article/details/53892797
 * 实上一种解决的办法就是要有一个称为平衡的附加结构条件即：任何结点的深度不得过深，而这种数据结构就是我们本篇要分析的平衡二叉树（AVL），
 * 它本身也是一种二叉查找树,
 * AVL树只是实现平衡二叉树的一种方法，它还有很多的其他实现方法如红黑树、替罪羊树、Treap、伸展树等，
 * 一棵AVL树是其每个结点的左子树和右子树的高度最多相差1的二叉查找树(空树的高度为-1)，
 * 这个差值也称为平衡因子（其取值可以是1，0，-1，平衡因子是某个结点左右子树层数的差值)
 * 无论是插入还是删除，只有那些从插入或者删除点到根结点的路径上的结点的平衡才有可能被改变，因为只有这些结点
 * 的子树才可能发生变化，所以最终也只需针对这些点进行平衡修复操作即可。
 */
public class BalancedBinaryTree_AVL {

}
